Суть метода Поппера применительно к отладке

Обычный (наивный) подход к отладке: вы видите ошибку и начинаете строить догадки, а затем искать им подтверждение. "Наверное, баг в функции calculateTotal", — думаете вы и идёте смотреть на её код, чтобы найти доказательства своей правоты.

Поппер говорит: это ловушка! Вы подсознательно будете искать и находить то, что подтверждает вашу идею, игнорируя противоречащие факты. Это называется подтверждающее искажение (confirmation bias).

Вместо этого нужно действовать как учёный-поперерианец:

Ваша гипотеза — это не "истина", а лишь предположение, которое нужно безжалостно пытаться уничтожить.

---

Пошаговый разбор на примере

Ситуация: Пользователь жалуется, что при добавлении товара в корзину итоговая сумма считается неверно.

Шаг 1: Формулируем чёткую гипотезу (нашу "научную теорию")

· Плохая гипотеза: "Что-то не так с корзиной."
· Хорошая, фальсифицируемая гипотеза (по Попперу): "Ошибка возникает в модуле CartCalculator, в методе applyDiscount(), когда применяется скидка более 50%."

Обратите внимание: хорошая гипотеза конкретна и уязвима для опровержения. Её можно проверить одним или несколькими тестами.

Шаг 2: Пытаемся опровергнуть гипотезу (фальсифицировать)

Мы не пишем тест, который "проверит, работает ли applyDiscount()". Мы пишем тест, который должен опровергнуть нашу гипотезу.

· Наша гипотеза: "applyDiscount() ломается при скидке > 50%."
· Следствие для теста (попытка опровержения): "Если моя гипотеза НЕверна, то тест с входными данными 'товар ценой 100, скидка 60%' должен УСПЕШНО выполниться и вернуть 40."

```javascript
// Это не тест "на подтверждение", а тест "на опровержение"
function test_applyDiscount_With60PercentDiscount() {
    const calculator = new CartCalculator();
    const result = calculator.applyDiscount(100, 60);
    
    // Если гипотеза НЕ верна, утверждение ниже должно быть истинным
    assert(result === 40); // Ожидаем 100 - (100 * 0.6) = 40
}
```

Шаг 3: Анализируем результат

· Сценарий А: Тест ПРОХОДИТ (assert не выбросил ошибку).
  · Что это значит? Наша гипотеза была опровергнута! Мы успешно фальсифицировали её. Баг НЕ в методе applyDiscount() с большими скидками.
  · Что делать? Отбрасываем эту гипотезу и формулируем новую. "Отлично, эта идея была ложной. Значит, проблема не здесь. Возможно, баг в модуле TaxCalculator..." И мы двигаемся дальше, не потратив часы на бессмысленное копание в applyDiscount.
· Сценарий Б: Тест НЕ ПРОХОДИТ (assert падает, результат не 40, а, скажем, 10).
  · Что это значит? Нам не удалось опровергнуть гипотезу. Более того, мы нашли прямое свидетельство, что она верна. Гипотеза подтвердилась, выдержав попытку уничтожения.
  · Что делать? Теперь можно с чистой совестью идти в код метода applyDiscount() и искать, почему при скидке 60% возвращается 10. Мы точно знаем, где копать.

---

Почему этот метод такой мощный?

1. Борется с когнитивными искажениями. Он заставляет ваш мозг искать не "да, я был прав", а "я был неправ, иду дальше". Это ускоряет поиск истины.
2. Экономит огромное количество времени. Вы не тратите часы, углубляясь в детали модуля, который на самом деле ни при чём. Неудачная гипотеза отбрасывается за секунды падения теста.
3. Систематизирует процесс отладки. Вместо хаотичного блуждания по коду вы действуете как учёный: "Гипотеза -> Проверка на опровержение -> Верификация/Фальсификация -> Новая гипотеза".
4. Создает "тест на будущее". Удачно опровергнувший гипотезу тест (который прошёл) можно добавить в вашу тестовую батарею, чтобы гарантировать, что регрессия в этом месте не появится. А тест, который подтвердил баг, станет тестом на его исправление.

Аналогия из детектива

· Наивный подход: Детектив считает, что "дворецкий виновен". Он ищет только улики, которые указывают на дворецкого.
· Подход Поппера: Детектив считает, что "дворецкий виновен". И затем он пытается найти дворецкому алиби. Если находит железное алиби — гипотеза опровергнута, можно сразу переходить к другому подозреваемому, не тратя время зря.

Итог: В следующий раз, когда будете искать баг, не спрашивайте себя "Как мне доказать, что баг здесь?". Спросите: "Какой самый простой эксперимент я могу поставить, чтобы доказать, что баг НЕ здесь?".

Сломать свою собственную идею — это не поражение, а самый быстрый путь к правильному решению.